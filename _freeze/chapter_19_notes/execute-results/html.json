{
  "hash": "7011fe03974e9c0ade55a5f90ce2919a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R for Data Science, 2nd Edition - Chapter 19 Notes\"\nfreeze: true\nformat:\n    html:\n        toc: true\n        toc-title: Contents\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# 19 Joins\n\nThere are two main types of joins: mutating and filtering\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(nycflights13)\n```\n:::\n\n\n\n## 19.2 Keys\n\n**Primary and foreign keys**. Primary keys uniquely identify an observation. A foreign key a variable or set of variables that corresponds to a primary key in another table.\n\ncheck that your primary key is unique:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplanes |> \n  count(tailnum) |> \n  filter(n > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 2\n# ℹ 2 variables: tailnum <chr>, n <int>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 0 × 2\n#> # ℹ 2 variables: tailnum <chr>, n <int>\n\nweather |> \n  count(time_hour, origin) |> \n  filter(n > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 3\n# ℹ 3 variables: time_hour <dttm>, origin <chr>, n <int>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 0 × 3\n#> # ℹ 3 variables: time_hour <dttm>, origin <chr>, n <int>\n```\n:::\n\n\nShould probably also check for missing values on primary keys:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplanes |> \n  filter(is.na(tailnum))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 9\n# ℹ 9 variables: tailnum <chr>, year <int>, type <chr>, manufacturer <chr>,\n#   model <chr>, engines <int>, seats <int>, speed <int>, engine <chr>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 0 × 9\n#> # ℹ 9 variables: tailnum <chr>, year <int>, type <chr>, manufacturer <chr>,\n#> #   model <chr>, engines <int>, seats <int>, speed <int>, engine <chr>\n\nweather |> \n  filter(is.na(time_hour) | is.na(origin))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 15\n# ℹ 15 variables: origin <chr>, year <int>, month <int>, day <int>, hour <int>,\n#   temp <dbl>, dewp <dbl>, humid <dbl>, wind_dir <dbl>, wind_speed <dbl>,\n#   wind_gust <dbl>, precip <dbl>, pressure <dbl>, visib <dbl>,\n#   time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 0 × 15\n#> # ℹ 15 variables: origin <chr>, year <int>, month <int>, day <int>,\n#> #   hour <int>, temp <dbl>, dewp <dbl>, humid <dbl>, wind_dir <dbl>, …\n```\n:::\n\n\nfor the `flights` data frame, a compound primary key can be formed like so:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  count(time_hour, carrier, flight) |> \n  filter(n > 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 4\n# ℹ 4 variables: time_hour <dttm>, carrier <chr>, flight <int>, n <int>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 0 × 4\n#> # ℹ 4 variables: time_hour <dttm>, carrier <chr>, flight <int>, n <int>\n```\n:::\n\n\nIf you don't have a clear primary key, you can use a surrogate:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 <- flights |> \n  mutate(id = row_number(), .before = 1)\nflights2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 20\n      id  year month   day dep_time sched_dep_time dep_delay arr_time\n   <int> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n 1     1  2013     1     1      517            515         2      830\n 2     2  2013     1     1      533            529         4      850\n 3     3  2013     1     1      542            540         2      923\n 4     4  2013     1     1      544            545        -1     1004\n 5     5  2013     1     1      554            600        -6      812\n 6     6  2013     1     1      554            558        -4      740\n 7     7  2013     1     1      555            600        -5      913\n 8     8  2013     1     1      557            600        -3      709\n 9     9  2013     1     1      557            600        -3      838\n10    10  2013     1     1      558            600        -2      753\n# ℹ 336,766 more rows\n# ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, carrier <chr>,\n#   flight <int>, tailnum <chr>, origin <chr>, dest <chr>, air_time <dbl>,\n#   distance <dbl>, hour <dbl>, minute <dbl>, time_hour <dttm>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 336,776 × 20\n#>      id  year month   day dep_time sched_dep_time dep_delay arr_time\n#>   <int> <int> <int> <int>    <int>          <int>     <dbl>    <int>\n#> 1     1  2013     1     1      517            515         2      830\n#> 2     2  2013     1     1      533            529         4      850\n#> 3     3  2013     1     1      542            540         2      923\n#> 4     4  2013     1     1      544            545        -1     1004\n#> 5     5  2013     1     1      554            600        -6      812\n#> 6     6  2013     1     1      554            558        -4      740\n#> # ℹ 336,770 more rows\n#> # ℹ 12 more variables: sched_arr_time <int>, arr_delay <dbl>, …\n```\n:::\n\n\n**Mutating joins**.\n\nMake a more narrow data frame first.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 <- flights |> \n  select(year, time_hour, origin, dest, tailnum, carrier)\nflights2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 6\n    year time_hour           origin dest  tailnum carrier\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>  \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6     \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV     \n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6     \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA     \n# ℹ 336,766 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 336,776 × 6\n#>    year time_hour           origin dest  tailnum carrier\n#>   <int> <dttm>              <chr>  <chr> <chr>   <chr>  \n#> 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA     \n#> 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA     \n#> 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA     \n#> 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6     \n#> 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL     \n#> 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA     \n#> # ℹ 336,770 more rows\n```\n:::\n\n\nadd airline information to flights\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 |>\n  left_join(airlines)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(carrier)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 7\n    year time_hour           origin dest  tailnum carrier name                  \n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>                 \n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines Inc. \n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines Inc. \n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines Inc.\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways       \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.  \n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines Inc. \n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      JetBlue Airways       \n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      ExpressJet Airlines I…\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      JetBlue Airways       \n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      American Airlines Inc.\n# ℹ 336,766 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Joining with `by = join_by(carrier)`\n#> # A tibble: 336,776 × 7\n#>    year time_hour           origin dest  tailnum carrier name                \n#>   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>               \n#> 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      United Air Lines In…\n#> 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      United Air Lines In…\n#> 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      American Airlines I…\n#> 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      JetBlue Airways     \n#> 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Delta Air Lines Inc.\n#> 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      United Air Lines In…\n#> # ℹ 336,770 more rows\n```\n:::\n\n\nFind weather when each flight departed. Note the use of select within `left_join()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 |> \n  left_join(weather |> select(origin, time_hour, temp, wind_speed))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(time_hour, origin)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 8\n    year time_hour           origin dest  tailnum carrier  temp wind_speed\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <dbl>      <dbl>\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6       37.9       11.5\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV       39.9       16.1\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6       37.9       13.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA       39.9       16.1\n# ℹ 336,766 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Joining with `by = join_by(time_hour, origin)`\n#> # A tibble: 336,776 × 8\n#>    year time_hour           origin dest  tailnum carrier  temp wind_speed\n#>   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <dbl>      <dbl>\n#> 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA       39.0       12.7\n#> 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA       39.9       15.0\n#> 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA       39.0       15.0\n#> 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6       39.0       15.0\n#> 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL       39.9       16.1\n#> 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA       39.0       12.7\n#> # ℹ 336,770 more rows\n```\n:::\n\n\nWhen no match is found for a row in `x`, the new variables get `NA` in the new columns.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 |> \n  filter(tailnum == \"N3ALAA\") |> \n  left_join(planes |> select(tailnum, type, engines, seats))\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(tailnum)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 63 × 9\n    year time_hour           origin dest  tailnum carrier type  engines seats\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>   <int> <int>\n 1  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n 2  2013 2013-01-02 18:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n 3  2013 2013-01-03 06:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n 4  2013 2013-01-07 19:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n 5  2013 2013-01-08 17:00:00 JFK    ORD   N3ALAA  AA      <NA>       NA    NA\n 6  2013 2013-01-16 06:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n 7  2013 2013-01-20 18:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n 8  2013 2013-01-22 17:00:00 JFK    ORD   N3ALAA  AA      <NA>       NA    NA\n 9  2013 2013-10-11 06:00:00 EWR    MIA   N3ALAA  AA      <NA>       NA    NA\n10  2013 2013-10-14 08:00:00 JFK    BOS   N3ALAA  AA      <NA>       NA    NA\n# ℹ 53 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Joining with `by = join_by(tailnum)`\n#> # A tibble: 63 × 9\n#>    year time_hour           origin dest  tailnum carrier type  engines seats\n#>   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>   <int> <int>\n#> 1  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n#> 2  2013 2013-01-02 18:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n#> 3  2013 2013-01-03 06:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n#> 4  2013 2013-01-07 19:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n#> 5  2013 2013-01-08 17:00:00 JFK    ORD   N3ALAA  AA      <NA>       NA    NA\n#> 6  2013 2013-01-16 06:00:00 LGA    ORD   N3ALAA  AA      <NA>       NA    NA\n#> # ℹ 57 more rows\n```\n:::\n\n\n\nBy default, `left_join()` uses all columns that appear in both data frames as the join key. But you can and should specify the joining keys:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 |> \n  left_join(planes, join_by(tailnum))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 14\n   year.x time_hour           origin dest  tailnum carrier year.y type          \n    <int> <dttm>              <chr>  <chr> <chr>   <chr>    <int> <chr>         \n 1   2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA        1999 Fixed wing mu…\n 2   2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA        1998 Fixed wing mu…\n 3   2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA        1990 Fixed wing mu…\n 4   2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6        2012 Fixed wing mu…\n 5   2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL        1991 Fixed wing mu…\n 6   2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA        2012 Fixed wing mu…\n 7   2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6        2000 Fixed wing mu…\n 8   2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV        1998 Fixed wing mu…\n 9   2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6        2004 Fixed wing mu…\n10   2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA          NA <NA>          \n# ℹ 336,766 more rows\n# ℹ 6 more variables: manufacturer <chr>, model <chr>, engines <int>,\n#   seats <int>, speed <int>, engine <chr>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 336,776 × 14\n#>   year.x time_hour           origin dest  tailnum carrier year.y\n#>    <int> <dttm>              <chr>  <chr> <chr>   <chr>    <int>\n#> 1   2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA        1999\n#> 2   2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA        1998\n#> 3   2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA        1990\n#> 4   2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6        2012\n#> 5   2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL        1991\n#> 6   2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA        2012\n#> # ℹ 336,770 more rows\n#> # ℹ 7 more variables: type <chr>, manufacturer <chr>, model <chr>, …\n```\n:::\n\n\n\nThis is short for `join_by(tailnum == tailnum)`. That's fine is the same variables have the same names across data frames. If the names are different, then you need to specify the equality of variables across different columns names in the `join_by()` argument.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 |> \n  left_join(airports, join_by(dest == faa))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 13\n    year time_hour           origin dest  tailnum carrier name         lat   lon\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>      <dbl> <dbl>\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      George Bu…  30.0 -95.3\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      George Bu…  30.0 -95.3\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Miami Intl  25.8 -80.3\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      <NA>        NA    NA  \n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Hartsfiel…  33.6 -84.4\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Chicago O…  42.0 -87.9\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Fort Laud…  26.1 -80.2\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      Washingto…  38.9 -77.5\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      Orlando I…  28.4 -81.3\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      Chicago O…  42.0 -87.9\n# ℹ 336,766 more rows\n# ℹ 4 more variables: alt <dbl>, tz <dbl>, dst <chr>, tzone <chr>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 336,776 × 13\n#>    year time_hour           origin dest  tailnum carrier name                \n#>   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>               \n#> 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      George Bush Interco…\n#> 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      George Bush Interco…\n#> 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      Miami Intl          \n#> 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      <NA>                \n#> 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      Hartsfield Jackson …\n#> 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Chicago Ohare Intl  \n#> # ℹ 336,770 more rows\n#> # ℹ 6 more variables: lat <dbl>, lon <dbl>, alt <dbl>, tz <dbl>, …\n\nflights2 |> \n  left_join(airports, join_by(origin == faa))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 336,776 × 13\n    year time_hour           origin dest  tailnum carrier name         lat   lon\n   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>      <dbl> <dbl>\n 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Li…  40.7 -74.2\n 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia  40.8 -73.9\n 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Ke…  40.6 -73.8\n 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Ke…  40.6 -73.8\n 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia  40.8 -73.9\n 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Li…  40.7 -74.2\n 7  2013 2013-01-01 06:00:00 EWR    FLL   N516JB  B6      Newark Li…  40.7 -74.2\n 8  2013 2013-01-01 06:00:00 LGA    IAD   N829AS  EV      La Guardia  40.8 -73.9\n 9  2013 2013-01-01 06:00:00 JFK    MCO   N593JB  B6      John F Ke…  40.6 -73.8\n10  2013 2013-01-01 06:00:00 LGA    ORD   N3ALAA  AA      La Guardia  40.8 -73.9\n# ℹ 336,766 more rows\n# ℹ 4 more variables: alt <dbl>, tz <dbl>, dst <chr>, tzone <chr>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 336,776 × 13\n#>    year time_hour           origin dest  tailnum carrier name               \n#>   <int> <dttm>              <chr>  <chr> <chr>   <chr>   <chr>              \n#> 1  2013 2013-01-01 05:00:00 EWR    IAH   N14228  UA      Newark Liberty Intl\n#> 2  2013 2013-01-01 05:00:00 LGA    IAH   N24211  UA      La Guardia         \n#> 3  2013 2013-01-01 05:00:00 JFK    MIA   N619AA  AA      John F Kennedy Intl\n#> 4  2013 2013-01-01 05:00:00 JFK    BQN   N804JB  B6      John F Kennedy Intl\n#> 5  2013 2013-01-01 06:00:00 LGA    ATL   N668DN  DL      La Guardia         \n#> 6  2013 2013-01-01 05:00:00 EWR    ORD   N39463  UA      Newark Liberty Intl\n#> # ℹ 336,770 more rows\n#> # ℹ 6 more variables: lat <dbl>, lon <dbl>, alt <dbl>, tz <dbl>, …\n```\n:::\n\n\nOlder code may use `by` with a character vector to specify join keys. Prefer `join_by()`.\n\n\n**Filtering joins**. There are two types: **semi-joins** and **anti-joins**.\n\n**Semi-joins** keep all rows in `x` that have a match in `y`. Show just origin airports:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nairports |> \n  semi_join(flights2, join_by(faa == origin))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 3 × 8\n  faa   name                  lat   lon   alt    tz dst   tzone           \n  <chr> <chr>               <dbl> <dbl> <dbl> <dbl> <chr> <chr>           \n1 EWR   Newark Liberty Intl  40.7 -74.2    18    -5 A     America/New_York\n2 JFK   John F Kennedy Intl  40.6 -73.8    13    -5 A     America/New_York\n3 LGA   La Guardia           40.8 -73.9    22    -5 A     America/New_York\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 3 × 8\n#>   faa   name                  lat   lon   alt    tz dst   tzone           \n#>   <chr> <chr>               <dbl> <dbl> <dbl> <dbl> <chr> <chr>           \n#> 1 EWR   Newark Liberty Intl  40.7 -74.2    18    -5 A     America/New_York\n#> 2 JFK   John F Kennedy Intl  40.6 -73.8    13    -5 A     America/New_York\n#> 3 LGA   La Guardia           40.8 -73.9    22    -5 A     America/New_York\n```\n:::\n\n\n**Anti-joins** are the opposite: they return all rows in `x` that don't have a match in `y`. These are useful for identifying implicit missing values.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 |> \n  anti_join(airports, join_by(dest == faa)) |> \n  distinct(dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 1\n  dest \n  <chr>\n1 BQN  \n2 SJU  \n3 STT  \n4 PSE  \n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 4 × 1\n#>   dest \n#>   <chr>\n#> 1 BQN  \n#> 2 SJU  \n#> 3 STT  \n#> 4 PSE\n```\n:::\n\n\n\nFind which `tailnum()` are missing from `planes`:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights2 |>\n  anti_join(planes, join_by(tailnum)) |> \n  distinct(tailnum)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 722 × 1\n   tailnum\n   <chr>  \n 1 N3ALAA \n 2 N3DUAA \n 3 N542MQ \n 4 N730MQ \n 5 N9EAMQ \n 6 N532UA \n 7 N3EMAA \n 8 N518MQ \n 9 N3BAAA \n10 N3CYAA \n# ℹ 712 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 722 × 1\n#>   tailnum\n#>   <chr>  \n#> 1 N3ALAA \n#> 2 N3DUAA \n#> 3 N542MQ \n#> 4 N730MQ \n#> 5 N9EAMQ \n#> 6 N532UA \n#> # ℹ 716 more rows\n```\n:::\n\n\nExercises 19.3.4 look especially useful to try out.\n\n## 19.4 How do joins work?\n\n\n## 19.5 Non-equi joins\n\nThese are joins without a strict requirement of equality of keys. This makes keeping both keys used in the join more useful, since they may be slightly different. We could have done this in the earlier equi joins above:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# x |> inner_join(y, join_by(key == key), keep = TRUE)\n# #> # A tibble: 2 × 4\n# #>   key.x val_x key.y val_y\n# #>   <dbl> <chr> <dbl> <chr>\n# #> 1     1 x1        1 y1   \n# #> 2     2 x2        2 y2\n```\n:::\n\n\nYou can, for example, do matches like `x$key` > `y$key`.\n\n- Cross joins match every pair of rows.\n- Inequality joins use <, <=, >, and >= instead of ==.\n- Rolling joins are similar to inequality joins but only find the closest match.\n- Overlap joins are a special type of inequality join designed to work with ranges.\n\nCross joins are the cartesian product of rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\ndf |> cross_join(df)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 16 × 2\n   name.x name.y\n   <chr>  <chr> \n 1 John   John  \n 2 John   Simon \n 3 John   Tracy \n 4 John   Max   \n 5 Simon  John  \n 6 Simon  Simon \n 7 Simon  Tracy \n 8 Simon  Max   \n 9 Tracy  John  \n10 Tracy  Simon \n11 Tracy  Tracy \n12 Tracy  Max   \n13 Max    John  \n14 Max    Simon \n15 Max    Tracy \n16 Max    Max   \n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 16 × 2\n#>   name.x name.y\n#>   <chr>  <chr> \n#> 1 John   John  \n#> 2 John   Simon \n#> 3 John   Tracy \n#> 4 John   Max   \n#> 5 Simon  John  \n#> 6 Simon  Simon \n#> # ℹ 10 more rows\n```\n:::\n\n\nInequality  joins can be used to generate all combinations, instead of all permutations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(id = 1:4, name = c(\"John\", \"Simon\", \"Tracy\", \"Max\"))\n\ndf |> inner_join(df, join_by(id < id))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n   id.x name.x  id.y name.y\n  <int> <chr>  <int> <chr> \n1     1 John       2 Simon \n2     1 John       3 Tracy \n3     1 John       4 Max   \n4     2 Simon      3 Tracy \n5     2 Simon      4 Max   \n6     3 Tracy      4 Max   \n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 6 × 4\n#>    id.x name.x  id.y name.y\n#>   <int> <chr>  <int> <chr> \n#> 1     1 John       2 Simon \n#> 2     1 John       3 Tracy \n#> 3     1 John       4 Max   \n#> 4     2 Simon      3 Tracy \n#> 5     2 Simon      4 Max   \n#> 6     3 Tracy      4 Max\n```\n:::\n\n\nRolling joins are similar to inequality joins, but only give you the closest row that satisfies the inequality:\n\n**Rolling joins are particularly useful when you have two tables of dates that don’t perfectly line up and you want to find (e.g.) the closest date in table 1 that comes before (or after) some date in table 2.**\n\nQuarterly party planning for employee birthdays:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparties <- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\"))\n)\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\nemployees <- tibble(\n  name = sample(babynames::babynames$name, 100),\n  birthday = ymd(\"2022-01-01\") + (sample(365, 100, replace = TRUE) - 1)\n)\nemployees\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 2\n   name     birthday  \n   <chr>    <date>    \n 1 Kemba    2022-01-22\n 2 Orean    2022-06-26\n 3 Kirstyn  2022-02-11\n 4 Amparo   2022-11-11\n 5 Belen    2022-03-25\n 6 Rayshaun 2022-01-11\n 7 Brazil   2022-05-01\n 8 Chaston  2022-10-29\n 9 Reyn     2022-03-26\n10 Ogechi   2022-12-31\n# ℹ 90 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 100 × 2\n#>   name     birthday  \n#>   <chr>    <date>    \n#> 1 Kemba    2022-01-22\n#> 2 Orean    2022-06-26\n#> 3 Kirstyn  2022-02-11\n#> 4 Amparo   2022-11-11\n#> 5 Belen    2022-03-25\n#> 6 Rayshaun 2022-01-11\n#> # ℹ 94 more rows\n```\n:::\n\n\n\nFor each employee we want to find the last party date that comes before (or on) their birthday. We can express that with a rolling join. The `closest()` function takes this from an inequality join to a rolling join:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees |> \n  left_join(parties, join_by(closest(birthday >= party)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 4\n   name     birthday       q party     \n   <chr>    <date>     <int> <date>    \n 1 Kemba    2022-01-22     1 2022-01-10\n 2 Orean    2022-06-26     2 2022-04-04\n 3 Kirstyn  2022-02-11     1 2022-01-10\n 4 Amparo   2022-11-11     4 2022-10-03\n 5 Belen    2022-03-25     1 2022-01-10\n 6 Rayshaun 2022-01-11     1 2022-01-10\n 7 Brazil   2022-05-01     2 2022-04-04\n 8 Chaston  2022-10-29     4 2022-10-03\n 9 Reyn     2022-03-26     1 2022-01-10\n10 Ogechi   2022-12-31     4 2022-10-03\n# ℹ 90 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 100 × 4\n#>   name     birthday       q party     \n#>   <chr>    <date>     <int> <date>    \n#> 1 Kemba    2022-01-22     1 2022-01-10\n#> 2 Orean    2022-06-26     2 2022-04-04\n#> 3 Kirstyn  2022-02-11     1 2022-01-10\n#> 4 Amparo   2022-11-11     4 2022-10-03\n#> 5 Belen    2022-03-25     1 2022-01-10\n#> 6 Rayshaun 2022-01-11     1 2022-01-10\n#> # ℹ 94 more rows\n```\n:::\n\n\n\nThe problem with this is that folks with birthdays before January 10 don't get a party.\n\n**Overlap joins**. There are three helpers:\n\n- `between(x, y_lower, y_upper)` is short for x >= y_lower, x <= y_upper.\n- `within(x_lower, x_upper, y_lower, y_upper)` is short for x_lower >= y_lower, x_upper <= y_upper.\n- `overlaps(x_lower, x_upper, y_lower, y_upper)` is short for x_lower <= y_upper, x_upper >= y_lower.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparties <- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  start = ymd(c(\"2022-01-01\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  end = ymd(c(\"2022-04-03\", \"2022-07-11\", \"2022-10-02\", \"2022-12-31\"))\n)\nparties\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 4\n      q party      start      end       \n  <int> <date>     <date>     <date>    \n1     1 2022-01-10 2022-01-01 2022-04-03\n2     2 2022-04-04 2022-04-04 2022-07-11\n3     3 2022-07-11 2022-07-11 2022-10-02\n4     4 2022-10-03 2022-10-03 2022-12-31\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 4 × 4\n#>       q party      start      end       \n#>   <int> <date>     <date>     <date>    \n#> 1     1 2022-01-10 2022-01-01 2022-04-03\n#> 2     2 2022-04-04 2022-04-04 2022-07-11\n#> 3     3 2022-07-11 2022-07-11 2022-10-02\n#> 4     4 2022-10-03 2022-10-03 2022-12-31\n```\n:::\n\n\nUse a self-join to check the data entry quality:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparties |> \n  inner_join(parties, join_by(overlaps(start, end, start, end), q < q)) |> \n  select(start.x, end.x, start.y, end.y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n  start.x    end.x      start.y    end.y     \n  <date>     <date>     <date>     <date>    \n1 2022-04-04 2022-07-11 2022-07-11 2022-10-02\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 4\n#>   start.x    end.x      start.y    end.y     \n#>   <date>     <date>     <date>     <date>    \n#> 1 2022-04-04 2022-07-11 2022-07-11 2022-10-02\n```\n:::\n\n\nThere is an overlap. Fix:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nparties <- tibble(\n  q = 1:4,\n  party = ymd(c(\"2022-01-10\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  start = ymd(c(\"2022-01-01\", \"2022-04-04\", \"2022-07-11\", \"2022-10-03\")),\n  end = ymd(c(\"2022-04-03\", \"2022-07-10\", \"2022-10-02\", \"2022-12-31\"))\n)\n```\n:::\n\n\nNow assign a party\n\n\n::: {.cell}\n\n```{.r .cell-code}\nemployees |> \n  inner_join(parties, join_by(between(birthday, start, end)), unmatched = \"error\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 100 × 6\n   name     birthday       q party      start      end       \n   <chr>    <date>     <int> <date>     <date>     <date>    \n 1 Kemba    2022-01-22     1 2022-01-10 2022-01-01 2022-04-03\n 2 Orean    2022-06-26     2 2022-04-04 2022-04-04 2022-07-10\n 3 Kirstyn  2022-02-11     1 2022-01-10 2022-01-01 2022-04-03\n 4 Amparo   2022-11-11     4 2022-10-03 2022-10-03 2022-12-31\n 5 Belen    2022-03-25     1 2022-01-10 2022-01-01 2022-04-03\n 6 Rayshaun 2022-01-11     1 2022-01-10 2022-01-01 2022-04-03\n 7 Brazil   2022-05-01     2 2022-04-04 2022-04-04 2022-07-10\n 8 Chaston  2022-10-29     4 2022-10-03 2022-10-03 2022-12-31\n 9 Reyn     2022-03-26     1 2022-01-10 2022-01-01 2022-04-03\n10 Ogechi   2022-12-31     4 2022-10-03 2022-10-03 2022-12-31\n# ℹ 90 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 100 × 6\n#>   name     birthday       q party      start      end       \n#>   <chr>    <date>     <int> <date>     <date>     <date>    \n#> 1 Kemba    2022-01-22     1 2022-01-10 2022-01-01 2022-04-03\n#> 2 Orean    2022-06-26     2 2022-04-04 2022-04-04 2022-07-10\n#> 3 Kirstyn  2022-02-11     1 2022-01-10 2022-01-01 2022-04-03\n#> 4 Amparo   2022-11-11     4 2022-10-03 2022-10-03 2022-12-31\n#> 5 Belen    2022-03-25     1 2022-01-10 2022-01-01 2022-04-03\n#> 6 Rayshaun 2022-01-11     1 2022-01-10 2022-01-01 2022-04-03\n#> # ℹ 94 more rows\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n:::\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}