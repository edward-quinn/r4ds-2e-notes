{
  "hash": "39adaa66aa1cc6c9238332b62a6bd0cf",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R for Data Science, 2nd Edition - Chapter 25 Notes\"\nfreeze: true\nformat:\n    html:\n        toc: true\neditor_options: \n  chunk_output_type: console\n---\n\n# 25 Functions\n\nWhy use functions?\n\n1. You can give a function an evocative name that makes your code easier to understand.\n\n2. As requirements change, you only need to update code in one place, instead of many.\n\n3. You eliminate the chance of making incidental mistakes when you copy and paste (i.e. updating a variable name in one place, but not in another).\n\n4. It makes it easier to reuse work from project-to-project, increasing your productivity over time.\n\nUse functions when you find yourself repeating your code more than once. Here are the functions we'll learn about:\n\n-   Vector functions take one or more vectors as input and return a vector as output.\n-   Data frame functions take a data frame as input and return a data frame as output.\n-   Plot functions that take a data frame as input and return a plot as output.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(nycflights13)\n```\n:::\n\n\n\n\n## 25.2 Vector functions\n\nHere is an example of a rescaling function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  a = rnorm(5),\n  b = rnorm(5),\n  c = rnorm(5),\n  d = rnorm(5),\n)\n\ndf |> mutate(\n  a = (a - min(a, na.rm = TRUE)) / \n    (max(a, na.rm = TRUE) - min(a, na.rm = TRUE)),\n  b = (b - min(a, na.rm = TRUE)) / \n    (max(b, na.rm = TRUE) - min(b, na.rm = TRUE)),\n  c = (c - min(c, na.rm = TRUE)) / \n    (max(c, na.rm = TRUE) - min(c, na.rm = TRUE)),\n  d = (d - min(d, na.rm = TRUE)) / \n    (max(d, na.rm = TRUE) - min(d, na.rm = TRUE)),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n       a       b     c     d\n   <dbl>   <dbl> <dbl> <dbl>\n1 1      -0.361  0.859 0.831\n2 0.0980 -0.0264 1     1    \n3 0.765   0.639  0     0    \n4 0       0.181  0.374 0.131\n5 0.529   0.262  0.710 0.589\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 5 × 4\n#>       a       b     c     d\n#>   <dbl>   <dbl> <dbl> <dbl>\n#> 1 0.339  0.387  0.291 0    \n#> 2 0.880 -0.613  0.611 0.557\n#> 3 0     -0.0833 1     0.752\n#> 4 0.795 -0.0822 0     1    \n#> 5 1     -0.0952 0.580 0.394\n```\n:::\n\n\n\nHere is the function:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrescale01 <- function(x) {\n  (x - min(x, na.rm = TRUE)) / (max(x, na.rm = TRUE) - min(x, na.rm = TRUE))\n}\n```\n:::\n\n\nNow call the function with mutate for cleaner code:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> mutate(\n  a = rescale01(a),\n  b = rescale01(b),\n  c = rescale01(c),\n  d = rescale01(d),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n       a     b     c     d\n   <dbl> <dbl> <dbl> <dbl>\n1 1      0     0.859 0.831\n2 0.0980 0.335 1     1    \n3 0.765  1     0     0    \n4 0      0.543 0.374 0.131\n5 0.529  0.624 0.710 0.589\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 5 × 4\n#>       a     b     c     d\n#>   <dbl> <dbl> <dbl> <dbl>\n#> 1 0.339 1     0.291 0    \n#> 2 0.880 0     0.611 0.557\n#> 3 0     0.530 1     0.752\n#> 4 0.795 0.531 0     1    \n#> 5 1     0.518 0.580 0.394\n```\n:::\n\n\n\n**Vector functions** work well inside of `mutate()` and `filter()` return a vector that is the same length as the input vector.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nz_score <- function(x) {\n  (x - mean(x, na.rm = TRUE)) / sd(x, na.rm = TRUE)\n}\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclamp <- function(x, min, max) {\n  case_when(\n    x < min ~ min,\n    x > max ~ max,\n    .default = x\n  )\n}\n\nclamp(1:10, min = 3, max = 7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] 3 3 3 4 5 6 7 7 7 7\n```\n\n\n:::\n\n```{.r .cell-code}\n#>  [1] 3 3 3 4 5 6 7 7 7 7\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfirst_upper <- function(x) {\n  str_sub(x, 1, 1) <- str_to_upper(str_sub(x, 1, 1))\n  x\n}\n\nfirst_upper(\"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"Hello\"\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# https://twitter.com/NVlabormarket/status/1571939851922198530\nclean_number <- function(x) {\n  is_pct <- str_detect(x, \"%\")\n  num <- x |> \n    str_remove_all(\"%\") |> \n    str_remove_all(\",\") |> \n    str_remove_all(fixed(\"$\")) |> \n    as.numeric()\n  if_else(is_pct, num / 100, num)\n}\n\nclean_number(\"$12,300\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 12300\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 12300\nclean_number(\"45%\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.45\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0.45\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfix_na <- function(x) {\n  if_else(x %in% c(997, 998, 999), NA, x)\n}\n```\n:::\n\n\n\n**Summary functions** are another important family of functions that return a single value for use in `summarize()`. \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncommas <- function(x) {\n  str_flatten(x, collapse = \", \", last = \" and \")\n}\n\ncommas(c(\"cat\", \"dog\", \"pigeon\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"cat, dog and pigeon\"\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] \"cat, dog and pigeon\"\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncv <- function(x, na.rm = FALSE) {\n  sd(x, na.rm = na.rm) / mean(x, na.rm = na.rm)\n}\n\ncv(runif(100, min = 0, max = 50))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.639585\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0.5196276\ncv(runif(100, min = 0, max = 500))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.5552002\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 0.5652554\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# https://twitter.com/gbganalyst/status/1571619641390252033\nn_missing <- function(x) {\n  sum(is.na(x))\n} \n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mean absolute percentage error\n\n\n# https://twitter.com/neilgcurrie/status/1571607727255834625\nmape <- function(actual, predicted) {\n  sum(abs((actual - predicted) / actual)) / length(actual)\n}\n```\n:::\n\n\n\n## 25.3 Data frame functions\n\n\nIf copying multiple verbs multiple times, you probably need a data frame function.\n\nYou will need to deal with the problem of indirection, resulting from tidy evaluation. The solution is to us embracing with `{{ }}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped_mean <- function(df, group_var, mean_var) {\n  df |> \n    group_by(group_var) |> \n    summarize(mean(mean_var))\n}\n```\n:::\n\n\nThe following will error out:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# diamonds |> grouped_mean(cut, carat)\n# #> Error in `group_by()`:\n# #> ! Must group by variables found in `.data`.\n# #> ✖ Column `group_var` is not found.\n```\n:::\n\n\nAn illustration of the problem:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- tibble(\n  mean_var = 1,\n  group_var = \"g\",\n  group = 1,\n  x = 10,\n  y = 100\n)\n\ndf |> grouped_mean(group, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  group_var `mean(mean_var)`\n  <chr>                <dbl>\n1 g                        1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 2\n#>   group_var `mean(mean_var)`\n#>   <chr>                <dbl>\n#> 1 g                        1\ndf |> grouped_mean(group, y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  group_var `mean(mean_var)`\n  <chr>                <dbl>\n1 g                        1\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 2\n#>   group_var `mean(mean_var)`\n#>   <chr>                <dbl>\n#> 1 g                        1\n```\n:::\n\n\nWe are returning values, but it is the \"mean\" of a single value, which is being returned as `1`.\n\nWe need to tell `dplyr` to run verbs on the values *inside* of the variable, and not to look for a variable with the argument name. We don't actually have a variable called `mean_var` or `group_var`.\n\nUse `{{ }}` to solve this problem.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngrouped_mean <- function(df, group_var, mean_var) {\n  df |> \n    group_by({{ group_var }}) |> \n    summarize(mean({{ mean_var }}))\n}\n\ndf |> grouped_mean(group, x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  group `mean(x)`\n  <dbl>     <dbl>\n1     1        10\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 2\n#>   group `mean(x)`\n#>   <dbl>     <dbl>\n#> 1     1        10\n```\n:::\n\n\nWe need to embrace when **Data-masking** (`arrange()`, `filter()`, `summarize()`) or **Tidy-selection** (`select()`, `relocate()`, `rename()`) occur.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary6 <- function(data, var) {\n  data |> summarize(\n    min = min({{ var }}, na.rm = TRUE),\n    mean = mean({{ var }}, na.rm = TRUE),\n    median = median({{ var }}, na.rm = TRUE),\n    max = max({{ var }}, na.rm = TRUE),\n    n = n(),\n    n_miss = sum(is.na({{ var }})),\n    .groups = \"drop\"\n  )\n}\n\ndiamonds |> summary6(carat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 6\n    min  mean median   max     n n_miss\n  <dbl> <dbl>  <dbl> <dbl> <int>  <int>\n1   0.2 0.798    0.7  5.01 53940      0\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 6\n#>     min  mean median   max     n n_miss\n#>   <dbl> <dbl>  <dbl> <dbl> <int>  <int>\n#> 1   0.2 0.798    0.7  5.01 53940      0\n```\n:::\n\n\n(Whenever you wrap summarize() in a helper, we think it’s good practice to set .groups = \"drop\" to both avoid the message and leave the data in an ungrouped state.)\n\nIf you wrap `summarize()` within a function, then it can be used on grouped data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  group_by(cut) |> \n  summary6(carat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 7\n  cut         min  mean median   max     n n_miss\n  <ord>     <dbl> <dbl>  <dbl> <dbl> <int>  <int>\n1 Fair       0.22 1.05    1     5.01  1610      0\n2 Good       0.23 0.849   0.82  3.01  4906      0\n3 Very Good  0.2  0.806   0.71  4    12082      0\n4 Premium    0.2  0.892   0.86  4.01 13791      0\n5 Ideal      0.2  0.703   0.54  3.5  21551      0\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 5 × 7\n#>   cut         min  mean median   max     n n_miss\n#>   <ord>     <dbl> <dbl>  <dbl> <dbl> <int>  <int>\n#> 1 Fair       0.22 1.05    1     5.01  1610      0\n#> 2 Good       0.23 0.849   0.82  3.01  4906      0\n#> 3 Very Good  0.2  0.806   0.71  4    12082      0\n#> 4 Premium    0.2  0.892   0.86  4.01 13791      0\n#> 5 Ideal      0.2  0.703   0.54  3.5  21551      0\n```\n:::\n\n\nFurthermore, since the arguments to summarize are data-masking, so is the var argument to summary6(). That means you can also summarize computed variables:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  group_by(cut) |> \n  summary6(log10(carat))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 7\n  cut          min    mean  median   max     n n_miss\n  <ord>      <dbl>   <dbl>   <dbl> <dbl> <int>  <int>\n1 Fair      -0.658 -0.0273  0      0.700  1610      0\n2 Good      -0.638 -0.133  -0.0862 0.479  4906      0\n3 Very Good -0.699 -0.164  -0.149  0.602 12082      0\n4 Premium   -0.699 -0.125  -0.0655 0.603 13791      0\n5 Ideal     -0.699 -0.225  -0.268  0.544 21551      0\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 5 × 7\n#>   cut          min    mean  median   max     n n_miss\n#>   <ord>      <dbl>   <dbl>   <dbl> <dbl> <int>  <int>\n#> 1 Fair      -0.658 -0.0273  0      0.700  1610      0\n#> 2 Good      -0.638 -0.133  -0.0862 0.479  4906      0\n#> 3 Very Good -0.699 -0.164  -0.149  0.602 12082      0\n#> 4 Premium   -0.699 -0.125  -0.0655 0.603 13791      0\n#> 5 Ideal     -0.699 -0.225  -0.268  0.544 21551      0\n```\n:::\n\n\nTo summarize multiple variables, use `across()`.\n\n\nHere's a version of count that also calculates proportions.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# https://twitter.com/Diabb6/status/1571635146658402309\ncount_prop <- function(df, var, sort = FALSE) {\n  df |>\n    count({{ var }}, sort = sort) |>\n    mutate(prop = n / sum(n))\n}\n\ndiamonds |> count_prop(clarity)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  clarity     n   prop\n  <ord>   <int>  <dbl>\n1 I1        741 0.0137\n2 SI2      9194 0.170 \n3 SI1     13065 0.242 \n4 VS2     12258 0.227 \n5 VS1      8171 0.151 \n6 VVS2     5066 0.0939\n7 VVS1     3655 0.0678\n8 IF       1790 0.0332\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 8 × 3\n#>   clarity     n   prop\n#>   <ord>   <int>  <dbl>\n#> 1 I1        741 0.0137\n#> 2 SI2      9194 0.170 \n#> 3 SI1     13065 0.242 \n#> 4 VS2     12258 0.227 \n#> 5 VS1      8171 0.151 \n#> 6 VVS2     5066 0.0939\n#> # ℹ 2 more rows\n```\n:::\n\n\n\nFinding sorted unique values of a subset of the data:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nunique_where <- function(df, condition, var) {\n  df |> \n    filter({{ condition }}) |> \n    distinct({{ var }}) |> \n    arrange({{ var }})\n}\n\n# Find all the destinations in December\nflights |> unique_where(month == 12, dest)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 96 × 1\n   dest \n   <chr>\n 1 ABQ  \n 2 ALB  \n 3 ATL  \n 4 AUS  \n 5 AVL  \n 6 BDL  \n 7 BGR  \n 8 BHM  \n 9 BNA  \n10 BOS  \n# ℹ 86 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 96 × 1\n#>   dest \n#>   <chr>\n#> 1 ABQ  \n#> 2 ALB  \n#> 3 ATL  \n#> 4 AUS  \n#> 5 AVL  \n#> 6 BDL  \n#> # ℹ 90 more rows\n```\n:::\n\n\n\n**Data-masking vs. tidy-selection**\n\n| Situation                  | What you have | What you want         | Use this         | Example                                |\n| -------------------------- | ------------- | --------------------- | ---------------- | -------------------------------------- |\n| Column passed as bare name | `col`         | Use column **values** | `{{ col }}`      | `filter(df, {{ col }} > 0)`            |\n| Column name as string      | `\"col\"`       | Use column **values** | `.data[[col]]`   | `filter(df, .data[[col]] > 0)`         |\n| Column passed bare         | `cols`        | **Select columns**    | `{{ cols }}`     | `select(df, {{ cols }})`               |\n| Vector of column names     | `c(\"a\",\"b\")`  | **Select columns**    | `all_of()`       | `select(df, all_of(cols))`             |\n| Optional columns           | `c(\"a\",\"b\")`  | Select if present     | `any_of()`       | `select(df, any_of(cols))`             |\n| Apply function to columns  | tidy-select   | Multiple columns      | `across()`       | `mutate(df, across({{ cols }}, mean))` |\n| Programming w/ quosures    | expression    | Full NSE control      | `enquo()` / `!!` | `filter(df, !!q > 0)`                  |\n| Mix columns + env vars     | both          | Avoid name clash      | `.data` / `.env` | `filter(df, x > .env$cutoff)`          |\n\n\n\nWhat if you want to select variables inside of a function that uses data-masking? The following will not work:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# count_missing <- function(df, group_vars, x_var) {\n#   df |> \n#     group_by({{ group_vars }}) |> # this is a problem. group_by uses data masking, not tidy selection.\n#     summarize(\n#       n_miss = sum(is.na({{ x_var }})), \n#       .groups = \"drop\"\n#     )\n# }\n# \n# flights |> \n#   count_missing(c(year, month, day), dep_time)\n#> Error in `group_by()`:\n#> ℹ In argument: `c(year, month, day)`.\n#> Caused by error:\n#> ! `c(year, month, day)` must be size 336776 or 1, not 1010328.\n```\n:::\n\n\nUse the `pick()` function for tidy selection inside of a data masking function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncount_missing <- function(df, group_vars, x_var) {\n  df |> \n    group_by(pick({{ group_vars }})) |> \n    summarize(\n      n_miss = sum(is.na({{ x_var }})),\n      .groups = \"drop\"\n  )\n}\n\nflights |> \n  count_missing(c(year, month, day), dep_time)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 4\n    year month   day n_miss\n   <int> <int> <int>  <int>\n 1  2013     1     1      4\n 2  2013     1     2      8\n 3  2013     1     3     10\n 4  2013     1     4      6\n 5  2013     1     5      3\n 6  2013     1     6      1\n 7  2013     1     7      3\n 8  2013     1     8      4\n 9  2013     1     9      5\n10  2013     1    10      3\n# ℹ 355 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 365 × 4\n#>    year month   day n_miss\n#>   <int> <int> <int>  <int>\n#> 1  2013     1     1      4\n#> 2  2013     1     2      8\n#> 3  2013     1     3     10\n#> 4  2013     1     4      6\n#> 5  2013     1     5      3\n#> 6  2013     1     6      1\n#> # ℹ 359 more rows\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# https://twitter.com/pollicipes/status/1571606508944719876\ncount_wide <- function(data, rows, cols) {\n  data |> \n    count(pick(c({{ rows }}, {{ cols }}))) |> \n    pivot_wider(\n      names_from = {{ cols }}, # names_from uses tidy selection\n      values_from = n,\n      names_sort = TRUE,\n      values_fill = 0\n    )\n}\n\ndiamonds |> count_wide(c(clarity, color), cut)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 56 × 7\n   clarity color  Fair  Good `Very Good` Premium Ideal\n   <ord>   <ord> <int> <int>       <int>   <int> <int>\n 1 I1      D         4     8           5      12    13\n 2 I1      E         9    23          22      30    18\n 3 I1      F        35    19          13      34    42\n 4 I1      G        53    19          16      46    16\n 5 I1      H        52    14          12      46    38\n 6 I1      I        34     9           8      24    17\n 7 I1      J        23     4           8      13     2\n 8 SI2     D        56   223         314     421   356\n 9 SI2     E        78   202         445     519   469\n10 SI2     F        89   201         343     523   453\n# ℹ 46 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 56 × 7\n#>   clarity color  Fair  Good `Very Good` Premium Ideal\n#>   <ord>   <ord> <int> <int>       <int>   <int> <int>\n#> 1 I1      D         4     8           5      12    13\n#> 2 I1      E         9    23          22      30    18\n#> 3 I1      F        35    19          13      34    42\n#> 4 I1      G        53    19          16      46    16\n#> 5 I1      H        52    14          12      46    38\n#> 6 I1      I        34     9           8      24    17\n#> # ℹ 50 more rows\n```\n:::\n\n\n\n\n\n## 25.4 Plot functions\n\nInstead of returning a dataframe, you can return a plot from a function. `ggplot2::aes()` is a data-masking function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.1)\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-26-1.png){width=672}\n:::\n\n```{.r .cell-code}\ndiamonds |> \n  ggplot(aes(x = carat)) +\n  geom_histogram(binwidth = 0.05)\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-26-2.png){width=672}\n:::\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhistogram <- function(df, var, binwidth = NULL) {\n  df |> \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n\ndiamonds |> histogram(carat, 0.1)\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n\nBecause a ggplot2 object is returned, you can add on additional components with `+`.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndiamonds |> \n  histogram(carat, 0.1) +\n  labs(x = \"Size (in carats)\", y = \"Number of diamonds\")\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n**Adding more variables**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# https://twitter.com/tyler_js_smith/status/1574377116988104704\nlinearity_check <- function(df, x, y) {\n  df |>\n    ggplot(aes(x = {{ x }}, y = {{ y }})) +\n    geom_point() +\n    geom_smooth(method = \"loess\", formula = y ~ x, color = \"red\", se = FALSE) +\n    geom_smooth(method = \"lm\", formula = y ~ x, color = \"blue\", se = FALSE) \n}\n\nstarwars |> \n  filter(mass < 1000) |> \n  linearity_check(mass, height)\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# https://twitter.com/ppaxisa/status/1574398423175921665\nhex_plot <- function(df, x, y, z, bins = 20, fun = \"mean\") {\n  df |> \n    ggplot(aes(x = {{ x }}, y = {{ y }}, z = {{ z }})) + \n    stat_summary_hex(\n      aes(color = after_scale(fill)), # make border same color as fill\n      bins = bins, \n      fun = fun,\n    )\n}\n\ndiamonds |> hex_plot(carat, price, depth)\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n\n\n**Combining ggplot with other tidyverse**\n\n\nSorted bar chart function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsorted_bars <- function(df, var) {\n  df |> \n    # note the walrus operator here\n    mutate({{ var }} := fct_rev(fct_infreq({{ var }})))  |> \n    ggplot(aes(y = {{ var }})) +\n    geom_bar()\n}\n\ndiamonds |> sorted_bars(clarity)\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-31-1.png){width=672}\n:::\n:::\n\n\nConditional plot functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nconditional_bars <- function(df, condition, var) {\n  df |> \n    filter({{ condition }}) |> \n    ggplot(aes(x = {{ var }})) + \n    geom_bar()\n}\n\ndiamonds |> conditional_bars(cut == \"Good\", clarity)\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n\n\n\n**Labeling the plots you create**\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhistogram <- function(df, var, binwidth = NULL) {\n  df |> \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth)\n}\n```\n:::\n\n\nWhat if we could label the plot with the variable and binwidth used?\n\nUse `rlang::englue()` for this\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhistogram <- function(df, var, binwidth) {\n  label <- rlang::englue(\"A histogram of {{var}} with binwidth {binwidth}\")\n  \n  df |> \n    ggplot(aes(x = {{ var }})) + \n    geom_histogram(binwidth = binwidth) + \n    labs(title = label)\n}\n\ndiamonds |> histogram(carat, 0.1)\n```\n\n::: {.cell-output-display}\n![](chapter_25_notes_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n",
    "supporting": [
      "chapter_25_notes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}