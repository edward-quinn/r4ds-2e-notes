{
  "hash": "6eee2f9117e6fff0567b80725bfa6602",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R for Data Science, 2nd Edition - Chapter 26 Notes\"\nfreeze: true\nformat:\n    html:\n        toc: true\neditor_options: \n  chunk_output_type: console\n---\n\n# 26 Iteration\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n:::\n\n\n## 26.2 Modifying multiple columns\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1014)\ndf <- tibble(\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n```\n:::\n\n\nHow to get medians of each column?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> summarize(\n  n = n(),\n  a = median(a),\n  b = median(b),\n  c = median(c),\n  d = median(d),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n      n      a      b       c     d\n  <int>  <dbl>  <dbl>   <dbl> <dbl>\n1    10 -0.246 -0.287 -0.0567 0.144\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 5\n#>       n      a      b       c     d\n#>   <int>  <dbl>  <dbl>   <dbl> <dbl>\n#> 1    10 -0.246 -0.287 -0.0567 0.144\n```\n:::\n\n\nUse `across()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> summarize(\n  n = n(),\n  across(a:d, median),\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n      n      a      b       c     d\n  <int>  <dbl>  <dbl>   <dbl> <dbl>\n1    10 -0.246 -0.287 -0.0567 0.144\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 5\n#>       n      a      b       c     d\n#>   <int>  <dbl>  <dbl>   <dbl> <dbl>\n#> 1    10 -0.246 -0.287 -0.0567 0.144\n```\n:::\n\n\nKey arguments: `.cols`, `.fns`, and you can use `.names` if you want to control names of output columns. `if_any()` and `if_all()` may be important within `filter()` calls.\n\n`.cols` can be supplied with the same syntax as `select()`, and `everything()` and `where()`. Use `where()` to select based on type.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1014)\ndf <- tibble(\n  grp = sample(2, 10, replace = TRUE),\n  a = rnorm(10),\n  b = rnorm(10),\n  c = rnorm(10),\n  d = rnorm(10)\n)\n\ndf |> \n  group_by(grp) |> \n  summarize(across(everything(), median))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n    grp      a      b       c       d\n  <int>  <dbl>  <dbl>   <dbl>   <dbl>\n1     1 -0.244 -0.522 -0.0974 -0.251 \n2     2 -0.247  0.468  0.112   0.0700\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 2 × 5\n#>     grp      a      b       c       d\n#>   <int>  <dbl>  <dbl>   <dbl>   <dbl>\n#> 1     1 -0.244 -0.522 -0.0974 -0.251 \n#> 2     2 -0.247  0.468  0.112   0.0700\n```\n:::\n\n\nJust like other selectors, you can combine these with Boolean algebra. For example, `!where(is.numeric)` selects all non-numeric columns, and `starts_with(\"a\") & where(is.logical)` selects all logical columns whose name starts with “a”.\n\n**Calling a single function**.\n\n**Calling multiple functions**. (or multiple arguments). Here is an example of handling `NA` values in a call to `median()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1014)\nrnorm_na <- function(n, n_na, mean = 0, sd = 1) {\n  sample(c(rnorm(n - n_na, mean = mean, sd = sd), rep(NA, n_na)))\n}\n\ndf_miss <- tibble(\n  a = rnorm_na(5, 1),\n  b = rnorm_na(5, 1),\n  c = rnorm_na(5, 2),\n  d = rnorm(5)\n)\ndf_miss |> \n  summarize(\n    across(a:d, median),\n    n = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n      a     b     c     d     n\n  <dbl> <dbl> <dbl> <dbl> <int>\n1    NA    NA    NA 0.413     5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 5\n#>       a     b     c     d     n\n#>   <dbl> <dbl> <dbl> <dbl> <int>\n#> 1    NA    NA    NA 0.413     5\n```\n:::\n\n\nWe need to create a new function that calls `median()` with the desired arguments:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_miss |> \n  summarize(\n    across(a:d, function(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n       a      b      c     d     n\n   <dbl>  <dbl>  <dbl> <dbl> <int>\n1 -0.703 -0.265 -0.522 0.413     5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 5\n#>        a      b      c     d     n\n#>    <dbl>  <dbl>  <dbl> <dbl> <int>\n#> 1 -0.703 -0.265 -0.522 0.413     5\n```\n:::\n\n\n\nThis is verbose, so we can use anonymous function syntax (`\\(x)` recommended over `~ .x`).\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_miss |> \n  summarize(\n    across(a:d, \\(x) median(x, na.rm = TRUE)),\n    n = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 5\n       a      b      c     d     n\n   <dbl>  <dbl>  <dbl> <dbl> <int>\n1 -0.703 -0.265 -0.522 0.413     5\n```\n\n\n:::\n:::\n\n\nIf you want to supply more than one function in the call to `across()`, use a named list:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_miss |> \n  summarize(\n    across(a:d, list(\n      median = \\(x) median(x, na.rm = TRUE),\n      n_miss = \\(x) sum(is.na(x))\n    )),\n    n = n()\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 9\n  a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss     n\n     <dbl>    <int>    <dbl>    <int>    <dbl>    <int>    <dbl>    <int> <int>\n1   -0.703        1   -0.265        1   -0.522        2    0.413        0     5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 9\n#>   a_median a_n_miss b_median b_n_miss c_median c_n_miss d_median d_n_miss\n#>      <dbl>    <int>    <dbl>    <int>    <dbl>    <int>    <dbl>    <int>\n#> 1   -0.703        1   -0.265        1   -0.522        2    0.413        0\n#> # ℹ 1 more variable: n <int>\n```\n:::\n\n\n\n**Column names** are specified with the `.names` argument.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_miss |> \n  summarize(\n    across(\n      a:d,\n      list(\n        median = \\(x) median(x, na.rm = TRUE),\n        n_miss = \\(x) sum(is.na(x))\n      ),\n      .names = \"{.fn}_{.col}\"\n    ),\n    n = n(),\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 9\n  median_a n_miss_a median_b n_miss_b median_c n_miss_c median_d n_miss_d     n\n     <dbl>    <int>    <dbl>    <int>    <dbl>    <int>    <dbl>    <int> <int>\n1   -0.703        1   -0.265        1   -0.522        2    0.413        0     5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 9\n#>   median_a n_miss_a median_b n_miss_b median_c n_miss_c median_d n_miss_d\n#>      <dbl>    <int>    <dbl>    <int>    <dbl>    <int>    <dbl>    <int>\n#> 1   -0.703        1   -0.265        1   -0.522        2    0.413        0\n#> # ℹ 1 more variable: n <int>\n```\n:::\n\n\n`.names` is especially helpful when calling `mutate()` within `across()` to prevent overwriting columns, since the output of `across()` is given the same name as the inputs.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_miss |> \n  mutate(\n    across(a:d, \\(x) coalesce(x, 0))\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 4\n         a      b      c        d\n     <dbl>  <dbl>  <dbl>    <dbl>\n1 -0.00557 -0.283 -1.86  -0.783  \n2  0.255   -0.247 -0.522 -0.00289\n3 -1.40    -0.554  0.512  0.413  \n4 -2.44    -0.244  0      0.724  \n5  0        0      0      2.35   \n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 5 × 4\n#>          a      b      c        d\n#>      <dbl>  <dbl>  <dbl>    <dbl>\n#> 1 -0.00557 -0.283 -1.86  -0.783  \n#> 2  0.255   -0.247 -0.522 -0.00289\n#> 3 -1.40    -0.554  0.512  0.413  \n#> 4 -2.44    -0.244  0      0.724  \n#> 5  0        0      0      2.35\n```\n:::\n\n\nUse the `.names` argument to instead create new columns.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_miss |> \n  mutate(\n    across(a:d, \\(x) coalesce(x, 0), .names = \"{.col}_na_zero\")\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 8\n         a      b      c        d a_na_zero b_na_zero c_na_zero d_na_zero\n     <dbl>  <dbl>  <dbl>    <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n1 -0.00557 -0.283 -1.86  -0.783    -0.00557    -0.283    -1.86   -0.783  \n2  0.255   -0.247 -0.522 -0.00289   0.255      -0.247    -0.522  -0.00289\n3 -1.40    -0.554  0.512  0.413    -1.40       -0.554     0.512   0.413  \n4 -2.44    -0.244 NA      0.724    -2.44       -0.244     0       0.724  \n5 NA       NA     NA      2.35      0           0         0       2.35   \n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 5 × 8\n#>          a      b      c        d a_na_zero b_na_zero c_na_zero d_na_zero\n#>      <dbl>  <dbl>  <dbl>    <dbl>     <dbl>     <dbl>     <dbl>     <dbl>\n#> 1 -0.00557 -0.283 -1.86  -0.783    -0.00557    -0.283    -1.86   -0.783  \n#> 2  0.255   -0.247 -0.522 -0.00289   0.255      -0.247    -0.522  -0.00289\n#> 3 -1.40    -0.554  0.512  0.413    -1.40       -0.554     0.512   0.413  \n#> 4 -2.44    -0.244 NA      0.724    -2.44       -0.244     0       0.724  \n#> 5 NA       NA     NA      2.35      0           0         0       2.35\n```\n:::\n\n\n\n**Filtering**. Two variants of `across()` are provided for use inside of `filter()`: `if_any()` and `if_all()` \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# same as df_miss |> filter(is.na(a) | is.na(b) | is.na(c) | is.na(d))\ndf_miss |> filter(if_any(a:d, is.na))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 4\n      a      b     c     d\n  <dbl>  <dbl> <dbl> <dbl>\n1 -2.44 -0.244    NA 0.724\n2 NA    NA        NA 2.35 \n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 2 × 4\n#>       a      b     c     d\n#>   <dbl>  <dbl> <dbl> <dbl>\n#> 1 -2.44 -0.244    NA 0.724\n#> 2 NA    NA        NA 2.35\n\n# same as df_miss |> filter(is.na(a) & is.na(b) & is.na(c) & is.na(d))\ndf_miss |> filter(if_all(a:d, is.na))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 0 × 4\n# ℹ 4 variables: a <dbl>, b <dbl>, c <dbl>, d <dbl>\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 0 × 4\n#> # ℹ 4 variables: a <dbl>, b <dbl>, c <dbl>, d <dbl>\n```\n:::\n\n\n`across()` can also be quite useful inside of functions.\n\nA helper function to expand all date columns into year, month, and day columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nexpand_dates <- function(df) {\n  df |> \n    mutate(\n      across(where(is.Date), list(year = year, month = month, day = mday))\n    )\n}\n\ndf_date <- tibble(\n  name = c(\"Amy\", \"Bob\"),\n  date = ymd(c(\"2009-08-03\", \"2010-01-16\"))\n)\n\ndf_date |> \n  expand_dates()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n  name  date       date_year date_month date_day\n  <chr> <date>         <dbl>      <dbl>    <int>\n1 Amy   2009-08-03      2009          8        3\n2 Bob   2010-01-16      2010          1       16\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 2 × 5\n#>   name  date       date_year date_month date_day\n#>   <chr> <date>         <dbl>      <dbl>    <int>\n#> 1 Amy   2009-08-03      2009          8        3\n#> 2 Bob   2010-01-16      2010          1       16\n```\n:::\n\n\n\nDon't forget to use`{{ }}` when selecting columns inside of a function, since `across()` uses tidy-select.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummarize_means <- function(df, summary_vars = where(is.numeric)) {\n  df |> \n    summarize(\n      across({{ summary_vars }}, \\(x) mean(x, na.rm = TRUE)),\n      n = n(),\n      .groups = \"drop\"\n    )\n}\n\ndiamonds |> \n  group_by(cut) |> \n  summarize_means()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 9\n  cut       carat depth table price     x     y     z     n\n  <ord>     <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <int>\n1 Fair      1.05   64.0  59.1 4359.  6.25  6.18  3.98  1610\n2 Good      0.849  62.4  58.7 3929.  5.84  5.85  3.64  4906\n3 Very Good 0.806  61.8  58.0 3982.  5.74  5.77  3.56 12082\n4 Premium   0.892  61.3  58.7 4584.  5.97  5.94  3.65 13791\n5 Ideal     0.703  61.7  56.0 3458.  5.51  5.52  3.40 21551\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 5 × 9\n#>   cut       carat depth table price     x     y     z     n\n#>   <ord>     <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <int>\n#> 1 Fair      1.05   64.0  59.1 4359.  6.25  6.18  3.98  1610\n#> 2 Good      0.849  62.4  58.7 3929.  5.84  5.85  3.64  4906\n#> 3 Very Good 0.806  61.8  58.0 3982.  5.74  5.77  3.56 12082\n#> 4 Premium   0.892  61.3  58.7 4584.  5.97  5.94  3.65 13791\n#> 5 Ideal     0.703  61.7  56.0 3458.  5.51  5.52  3.40 21551\n\ndiamonds |> \n  group_by(cut) |> \n  summarize_means(c(carat, x:z))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 5 × 6\n  cut       carat     x     y     z     n\n  <ord>     <dbl> <dbl> <dbl> <dbl> <int>\n1 Fair      1.05   6.25  6.18  3.98  1610\n2 Good      0.849  5.84  5.85  3.64  4906\n3 Very Good 0.806  5.74  5.77  3.56 12082\n4 Premium   0.892  5.97  5.94  3.65 13791\n5 Ideal     0.703  5.51  5.52  3.40 21551\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 5 × 6\n#>   cut       carat     x     y     z     n\n#>   <ord>     <dbl> <dbl> <dbl> <dbl> <int>\n#> 1 Fair      1.05   6.25  6.18  3.98  1610\n#> 2 Good      0.849  5.84  5.85  3.64  4906\n#> 3 Very Good 0.806  5.74  5.77  3.56 12082\n#> 4 Premium   0.892  5.97  5.94  3.65 13791\n#> 5 Ideal     0.703  5.51  5.52  3.40 21551\n```\n:::\n\n\n\nThere is a connection between `across()` and `pivot_longer()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf |> \n  summarize(across(a:d, list(median = median, mean = mean)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 8\n  a_median  a_mean b_median  b_mean c_median  c_mean d_median d_mean\n     <dbl>   <dbl>    <dbl>   <dbl>    <dbl>   <dbl>    <dbl>  <dbl>\n1   -0.246 -0.0426    0.155 -0.0656   0.0480 -0.0297   -0.193 -0.200\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 8\n#>   a_median  a_mean b_median  b_mean c_median  c_mean d_median d_mean\n#>      <dbl>   <dbl>    <dbl>   <dbl>    <dbl>   <dbl>    <dbl>  <dbl>\n#> 1   -0.246 -0.0426    0.155 -0.0656   0.0480 -0.0297   -0.193 -0.200\n```\n:::\n\n\nCompare this to:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong <- df |> \n  pivot_longer(a:d) |> \n  group_by(name) |> \n  summarize(\n    median = median(value),\n    mean = mean(value)\n  )\nlong\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  name   median    mean\n  <chr>   <dbl>   <dbl>\n1 a     -0.246  -0.0426\n2 b      0.155  -0.0656\n3 c      0.0480 -0.0297\n4 d     -0.193  -0.200 \n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 4 × 3\n#>   name   median    mean\n#>   <chr>   <dbl>   <dbl>\n#> 1 a     -0.246  -0.0426\n#> 2 b      0.155  -0.0656\n#> 3 c      0.0480 -0.0297\n#> 4 d     -0.193  -0.200\n```\n:::\n\n\nAnd to get it back to the structure `across()` gives you, `pivot_wider()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlong |> \n  pivot_wider(\n    names_from = name,\n    values_from = c(median, mean),\n    names_vary = \"slowest\",\n    names_glue = \"{name}_{.value}\"\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 8\n  a_median  a_mean b_median  b_mean c_median  c_mean d_median d_mean\n     <dbl>   <dbl>    <dbl>   <dbl>    <dbl>   <dbl>    <dbl>  <dbl>\n1   -0.246 -0.0426    0.155 -0.0656   0.0480 -0.0297   -0.193 -0.200\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 8\n#>   a_median  a_mean b_median  b_mean c_median  c_mean d_median d_mean\n#>      <dbl>   <dbl>    <dbl>   <dbl>    <dbl>   <dbl>    <dbl>  <dbl>\n#> 1   -0.246 -0.0426    0.155 -0.0656   0.0480 -0.0297   -0.193 -0.200\n```\n:::\n\n\n\nThis is useful because occasionally you won't be able to solve a problem with `across()`, such as groups of columns that you want to compute with simultaneously. Here is an example of a weighted mean:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1014)\ndf_paired <- tibble(\n  a_val = rnorm(10),\n  a_wts = runif(10),\n  b_val = rnorm(10),\n  b_wts = runif(10),\n  c_val = rnorm(10),\n  c_wts = runif(10),\n  d_val = rnorm(10),\n  d_wts = runif(10)\n)\n```\n:::\n\n\nYou can do this with `pivot_longer()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_long <- df_paired |> \n  pivot_longer(\n    everything(), \n    names_to = c(\"group\", \".value\"), \n    names_sep = \"_\"\n  )\ndf_long\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 40 × 3\n   group     val   wts\n   <chr>   <dbl> <dbl>\n 1 a     -1.40   0.290\n 2 b     -1.86   0.461\n 3 c      0.935  0.528\n 4 d      2.76   0.709\n 5 a      0.255  0.678\n 6 b     -0.522  0.315\n 7 c      0.176  0.601\n 8 d      0.0465 0.874\n 9 a     -2.44   0.735\n10 b     -0.0526 0.175\n# ℹ 30 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 40 × 3\n#>   group    val   wts\n#>   <chr>  <dbl> <dbl>\n#> 1 a     -1.40  0.290\n#> 2 b     -1.86  0.461\n#> 3 c      0.935 0.528\n#> 4 d      2.76  0.709\n#> 5 a      0.255 0.678\n#> 6 b     -0.522 0.315\n#> # ℹ 34 more rows\n\ndf_long |> \n  group_by(group) |> \n  summarize(mean = weighted.mean(val, wts))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 2\n  group    mean\n  <chr>   <dbl>\n1 a     -0.207 \n2 b     -0.237 \n3 c      0.0208\n4 d      0.0655\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 4 × 2\n#>   group    mean\n#>   <chr>   <dbl>\n#> 1 a     -0.207 \n#> 2 b     -0.237 \n#> 3 c      0.0208\n#> 4 d      0.0655\n```\n:::\n\n\nfind missing values after grouping on columns you choose.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshow_missing <- function(df, group_vars, summary_vars = everything()) {\n  df |> \n    group_by(pick({{ group_vars }})) |> \n    summarize(\n      across({{ summary_vars }}, \\(x) sum(is.na(x))),\n      .groups = \"drop\"\n    ) |>\n    select(where(\\(x) any(x > 0)))\n}\nnycflights13::flights |> show_missing(c(year, month, day))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 365 × 9\n    year month   day dep_time dep_delay arr_time arr_delay tailnum air_time\n   <int> <int> <int>    <int>     <int>    <int>     <int>   <int>    <int>\n 1  2013     1     1        4         4        5        11       0       11\n 2  2013     1     2        8         8       10        15       2       15\n 3  2013     1     3       10        10       10        14       2       14\n 4  2013     1     4        6         6        6         7       2        7\n 5  2013     1     5        3         3        3         3       1        3\n 6  2013     1     6        1         1        1         3       0        3\n 7  2013     1     7        3         3        3         3       1        3\n 8  2013     1     8        4         4        4         7       1        7\n 9  2013     1     9        5         5        7         9       2        9\n10  2013     1    10        3         3        3         3       2        3\n# ℹ 355 more rows\n```\n\n\n:::\n:::\n\n\n\n\n## 26.3 Reading multiple files\n\n\nThe basic pattern is to use `list.files()`, then `purrr:map()`, then bind the rows together across elements of the list with `purrr:list_bind()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# \n# paths <- list.files(\"data/gapminder\", pattern = \"[.]xlsx$\", full.names = TRUE)\n# paths\n#>  [1] \"data/gapminder/1952.xlsx\" \"data/gapminder/1957.xlsx\"\n#>  [3] \"data/gapminder/1962.xlsx\" \"data/gapminder/1967.xlsx\"\n#>  [5] \"data/gapminder/1972.xlsx\" \"data/gapminder/1977.xlsx\"\n#>  [7] \"data/gapminder/1982.xlsx\" \"data/gapminder/1987.xlsx\"\n#>  [9] \"data/gapminder/1992.xlsx\" \"data/gapminder/1997.xlsx\"\n#> [11] \"data/gapminder/2002.xlsx\" \"data/gapminder/2007.xlsx\"\n```\n:::\n\n\nNow use `map()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# files <- map(paths, readxl::read_excel)\n# length(files)\n# #> [1] 12\n# \n# files[[1]]\n#> # A tibble: 142 × 5\n#>   country     continent lifeExp      pop gdpPercap\n#>   <chr>       <chr>       <dbl>    <dbl>     <dbl>\n#> 1 Afghanistan Asia         28.8  8425333      779.\n#> 2 Albania     Europe       55.2  1282697     1601.\n#> 3 Algeria     Africa       43.1  9279525     2449.\n#> 4 Angola      Africa       30.0  4232095     3521.\n#> 5 Argentina   Americas     62.5 17876956     5911.\n#> 6 Australia   Oceania      69.1  8691212    10040.\n#> # ℹ 136 more rows\n```\n:::\n\n\nNow combine elements of the list with `purrr::list_rbind()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# list_rbind(files)\n# #> # A tibble: 1,704 × 5\n# #>   country     continent lifeExp      pop gdpPercap\n# #>   <chr>       <chr>       <dbl>    <dbl>     <dbl>\n# #> 1 Afghanistan Asia         28.8  8425333      779.\n# #> 2 Albania     Europe       55.2  1282697     1601.\n# #> 3 Algeria     Africa       43.1  9279525     2449.\n# #> 4 Angola      Africa       30.0  4232095     3521.\n# #> 5 Argentina   Americas     62.5 17876956     5911.\n# #> 6 Australia   Oceania      69.1  8691212    10040.\n# #> # ℹ 1,698 more rows\n\n# Or we could do this:\n\n# paths |> \n#   map(readxl::read_excel) |> \n#   list_rbind()\n```\n:::\n\n\nAdding additional arguments to the function being applied to each element of the list can be accomplished with an anonymous function.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# paths |> \n#   map(\\(path) readxl::read_excel(path, n_max = 1)) |> \n#   list_rbind()\n# #> # A tibble: 12 × 5\n# #>   country     continent lifeExp      pop gdpPercap\n# #>   <chr>       <chr>       <dbl>    <dbl>     <dbl>\n# #> 1 Afghanistan Asia         28.8  8425333      779.\n# #> 2 Afghanistan Asia         30.3  9240934      821.\n# #> 3 Afghanistan Asia         32.0 10267083      853.\n# #> 4 Afghanistan Asia         34.0 11537966      836.\n# #> 5 Afghanistan Asia         36.1 13079460      740.\n# #> 6 Afghanistan Asia         38.4 14880372      786.\n# #> # ℹ 6 more rows\n```\n:::\n\n\nWhat if variables are in the file names?\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# paths |> set_names(basename) \n# #>                  1952.xlsx                  1957.xlsx \n# #> \"data/gapminder/1952.xlsx\" \"data/gapminder/1957.xlsx\" \n# #>                  1962.xlsx                  1967.xlsx \n# #> \"data/gapminder/1962.xlsx\" \"data/gapminder/1967.xlsx\" \n# #>                  1972.xlsx                  1977.xlsx \n# #> \"data/gapminder/1972.xlsx\" \"data/gapminder/1977.xlsx\" \n# #>                  1982.xlsx                  1987.xlsx \n# #> \"data/gapminder/1982.xlsx\" \"data/gapminder/1987.xlsx\" \n# #>                  1992.xlsx                  1997.xlsx \n# #> \"data/gapminder/1992.xlsx\" \"data/gapminder/1997.xlsx\" \n# #>                  2002.xlsx                  2007.xlsx \n# #> \"data/gapminder/2002.xlsx\" \"data/gapminder/2007.xlsx\"\n# \n# files <- paths |> \n#   set_names(basename) |> \n#   map(readxl::read_excel)\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# paths |> \n#   set_names(basename) |> \n#   map(readxl::read_excel) |> \n#   list_rbind(names_to = \"year\") |> \n#   mutate(year = parse_number(year))\n# #> # A tibble: 1,704 × 6\n# #>    year country     continent lifeExp      pop gdpPercap\n# #>   <dbl> <chr>       <chr>       <dbl>    <dbl>     <dbl>\n# #> 1  1952 Afghanistan Asia         28.8  8425333      779.\n# #> 2  1952 Albania     Europe       55.2  1282697     1601.\n# #> 3  1952 Algeria     Africa       43.1  9279525     2449.\n# #> 4  1952 Angola      Africa       30.0  4232095     3521.\n# #> 5  1952 Argentina   Americas     62.5 17876956     5911.\n# #> 6  1952 Australia   Oceania      69.1  8691212    10040.\n# #> # ℹ 1,698 more rows\n```\n:::\n\n\n\nIn cases where there is more than one variable in the file name:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# paths |> \n#   set_names() |> \n#   map(readxl::read_excel) |> \n#   list_rbind(names_to = \"year\") |> \n#   separate_wider_delim(year, delim = \"/\", names = c(NA, \"dir\", \"file\")) |> \n#   separate_wider_delim(file, delim = \".\", names = c(\"file\", \"ext\"))\n# #> # A tibble: 1,704 × 8\n# #>   dir       file  ext   country     continent lifeExp      pop gdpPercap\n# #>   <chr>     <chr> <chr> <chr>       <chr>       <dbl>    <dbl>     <dbl>\n# #> 1 gapminder 1952  xlsx  Afghanistan Asia         28.8  8425333      779.\n# #> 2 gapminder 1952  xlsx  Albania     Europe       55.2  1282697     1601.\n# #> 3 gapminder 1952  xlsx  Algeria     Africa       43.1  9279525     2449.\n# #> 4 gapminder 1952  xlsx  Angola      Africa       30.0  4232095     3521.\n# #> 5 gapminder 1952  xlsx  Argentina   Americas     62.5 17876956     5911.\n# #> 6 gapminder 1952  xlsx  Australia   Oceania      69.1  8691212    10040.\n# #> # ℹ 1,698 more rows\n```\n:::\n\n\nThis all works if the data you get are already tidy, but in many cases this is not true. Then, it is useful to explore the structure of the data you have been given.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf_types <- function(df) {\n  tibble(\n    col_name = names(df), \n    col_type = map_chr(df, vctrs::vec_ptype_full),\n    n_miss = map_int(df, \\(x) sum(is.na(x)))\n  )\n}\n\ndf_types(gapminder::gapminder)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 3\n  col_name  col_type      n_miss\n  <chr>     <chr>          <int>\n1 country   factor<39935>      0\n2 continent factor<be586>      0\n3 year      integer            0\n4 lifeExp   double             0\n5 pop       integer            0\n6 gdpPercap double             0\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 6 × 3\n#>   col_name  col_type  n_miss\n#>   <chr>     <chr>      <int>\n#> 1 year      double         0\n#> 2 country   character      0\n#> 3 continent character      0\n#> 4 lifeExp   double         0\n#> 5 pop       double         0\n#> 6 gdpPercap double         0\n```\n:::\n\n\nTwo functions that may prove useful in modifying heterogenous files are `map_if()` and `map_at()`.  \n\nHandle failures in calls to `map()` with `possibly()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# \n# files <- paths |> \n#   map(possibly(\\(path) readxl::read_excel(path), NULL))\n# \n# data <- files |> list_rbind()\n# \n# # Now figure out which files failed.\n# \n# failed <- map_vec(files, is.null)\n# paths[failed]\n# #> character(0)\n```\n:::\n\n\n\n\n## 26.4 Saving multiple outputs\n\n-   Saving multiple data frames into one database.\n-   Saving multiple data frames into multiple .csv files.\n-   Saving multiple plots to multiple .png files.\n\n\n**Writing to a database**\n\nThe following would work if we just had `.csv` files.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# con <- DBI::dbConnect(duckdb::duckdb())\n# duckdb::duckdb_read_csv(con, \"gapminder\", paths)\n```\n:::\n\n\nWe actually have `.xlsx` files, so we'll have to do this by hand. First, make a template.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# template <- readxl::read_excel(paths[[1]])\n# template$year <- 1952\n# template\n# #> # A tibble: 142 × 6\n# #>   country     continent lifeExp      pop gdpPercap  year\n# #>   <chr>       <chr>       <dbl>    <dbl>     <dbl> <dbl>\n# #> 1 Afghanistan Asia         28.8  8425333      779.  1952\n# #> 2 Albania     Europe       55.2  1282697     1601.  1952\n# #> 3 Algeria     Africa       43.1  9279525     2449.  1952\n# #> 4 Angola      Africa       30.0  4232095     3521.  1952\n# #> 5 Argentina   Americas     62.5 17876956     5911.  1952\n# #> 6 Australia   Oceania      69.1  8691212    10040.  1952\n# #> # ℹ 136 more rows\n```\n:::\n\n\nNow connect to the database, and create a database table with the template.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# \n# con <- DBI::dbConnect(duckdb::duckdb())\n# DBI::dbCreateTable(con, \"gapminder\", template)\n```\n:::\n\n\nNow the table is created with the correct variable types, but no data are in the table.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# con |> tbl(\"gapminder\")\n# #> # Source:   table<gapminder> [?? x 6]\n# #> # Database: DuckDB 1.4.4 [unknown@Linux 6.11.0-1018-azure:R 4.5.2/:memory:]\n# #> # ℹ 6 variables: country <chr>, continent <chr>, lifeExp <dbl>, pop <dbl>,\n# #> #   gdpPercap <dbl>, year <dbl>\n```\n:::\n\n\n\nNow write a function that will read in files and append them to the database table:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# append_file <- function(path) {\n#   df <- readxl::read_excel(path)\n#   df$year <- parse_number(basename(path))\n#   \n#   DBI::dbAppendTable(con, \"gapminder\", df)\n# }\n```\n:::\n\n\nWe don't actually need the output of this function. So it's a good time to use `walk()`.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# paths |> walk(append_file)\n\n# con |> \n#   tbl(\"gapminder\") |> \n#   count(year)\n# #> # Source:   SQL [?? x 2]\n# #> # Database: DuckDB 1.4.4 [unknown@Linux 6.11.0-1018-azure:R 4.5.2/:memory:]\n# #>    year     n\n# #>   <dbl> <dbl>\n# #> 1  1952   142\n# #> 2  1957   142\n# #> 3  1962   142\n# #> 4  1972   142\n# #> 5  1982   142\n# #> 6  1992   142\n# #> # ℹ more rows\n```\n:::\n\n\n\n**Writing csv files**. Here, they use `group_nest` to create a tibble per group.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_clarity <- diamonds |> \n  group_nest(clarity)\n\nby_clarity\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 2\n  clarity               data\n  <ord>   <list<tibble[,9]>>\n1 I1               [741 × 9]\n2 SI2            [9,194 × 9]\n3 SI1           [13,065 × 9]\n4 VS2           [12,258 × 9]\n5 VS1            [8,171 × 9]\n6 VVS2           [5,066 × 9]\n7 VVS1           [3,655 × 9]\n8 IF             [1,790 × 9]\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 8 × 2\n#>   clarity               data\n#>   <ord>   <list<tibble[,9]>>\n#> 1 I1               [741 × 9]\n#> 2 SI2            [9,194 × 9]\n#> 3 SI1           [13,065 × 9]\n#> 4 VS2           [12,258 × 9]\n#> 5 VS1            [8,171 × 9]\n#> 6 VVS2           [5,066 × 9]\n#> # ℹ 2 more rows\n```\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_clarity$data[[1]]\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 741 × 9\n   carat cut       color depth table price     x     y     z\n   <dbl> <ord>     <ord> <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n 1  0.32 Premium   E      60.9    58   345  4.38  4.42  2.68\n 2  1.17 Very Good J      60.2    61  2774  6.83  6.9   4.13\n 3  1.01 Premium   F      61.8    60  2781  6.39  6.36  3.94\n 4  1.01 Fair      E      64.5    58  2788  6.29  6.21  4.03\n 5  0.96 Ideal     F      60.7    55  2801  6.37  6.41  3.88\n 6  1.04 Premium   G      62.2    58  2801  6.46  6.41  4   \n 7  1    Fair      G      66.4    59  2808  6.16  6.09  4.07\n 8  1.2  Fair      F      64.6    56  2809  6.73  6.66  4.33\n 9  0.43 Very Good E      58.4    62   555  4.94  5     2.9 \n10  1.02 Premium   G      60.3    58  2815  6.55  6.5   3.94\n# ℹ 731 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 741 × 9\n#>   carat cut       color depth table price     x     y     z\n#>   <dbl> <ord>     <ord> <dbl> <dbl> <int> <dbl> <dbl> <dbl>\n#> 1  0.32 Premium   E      60.9    58   345  4.38  4.42  2.68\n#> 2  1.17 Very Good J      60.2    61  2774  6.83  6.9   4.13\n#> 3  1.01 Premium   F      61.8    60  2781  6.39  6.36  3.94\n#> 4  1.01 Fair      E      64.5    58  2788  6.29  6.21  4.03\n#> 5  0.96 Ideal     F      60.7    55  2801  6.37  6.41  3.88\n#> 6  1.04 Premium   G      62.2    58  2801  6.46  6.41  4   \n#> # ℹ 735 more rows\n```\n:::\n\n\n\nNow add a column with the name of the output file.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_clarity <- by_clarity |> \n  mutate(path = str_glue(\"diamonds-{clarity}.csv\"))\n\nby_clarity\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n  clarity               data path             \n  <ord>   <list<tibble[,9]>> <glue>           \n1 I1               [741 × 9] diamonds-I1.csv  \n2 SI2            [9,194 × 9] diamonds-SI2.csv \n3 SI1           [13,065 × 9] diamonds-SI1.csv \n4 VS2           [12,258 × 9] diamonds-VS2.csv \n5 VS1            [8,171 × 9] diamonds-VS1.csv \n6 VVS2           [5,066 × 9] diamonds-VVS2.csv\n7 VVS1           [3,655 × 9] diamonds-VVS1.csv\n8 IF             [1,790 × 9] diamonds-IF.csv  \n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 8 × 3\n#>   clarity               data path             \n#>   <ord>   <list<tibble[,9]>> <glue>           \n#> 1 I1               [741 × 9] diamonds-I1.csv  \n#> 2 SI2            [9,194 × 9] diamonds-SI2.csv \n#> 3 SI1           [13,065 × 9] diamonds-SI1.csv \n#> 4 VS2           [12,258 × 9] diamonds-VS2.csv \n#> 5 VS1            [8,171 × 9] diamonds-VS1.csv \n#> 6 VVS2           [5,066 × 9] diamonds-VVS2.csv\n#> # ℹ 2 more rows\n```\n:::\n\n\n\nTo write each of these files to disk, we need to vary two arguments, the object and the path. That would be a good time to use `map2()`, but again, we care more about the side effect than the returned value, so use `walk2()` instead.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# walk2(by_clarity$data, by_clarity$path, write_csv)\n```\n:::\n\n\n\n\n**Saving plots**. Use the same basic approach.\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncarat_histogram <- function(df) {\n  ggplot(df, aes(x = carat)) + geom_histogram(binwidth = 0.1)  \n}\n\ncarat_histogram(by_clarity$data[[1]])\n```\n\n::: {.cell-output-display}\n![](chapter_26_notes_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_clarity <- by_clarity |> \n  mutate(\n    plot = map(data, carat_histogram),\n    path = str_glue(\"clarity-{clarity}.png\")\n  )\n```\n:::\n\n\nNow use `walk2()` again:\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# walk2(\n#   by_clarity$path,\n#   by_clarity$plot,\n#   \\(path, plot) ggsave(path, plot, width = 6, height = 6)\n# )\n```\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nby_clarity\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 4\n  clarity               data path             plot      \n  <ord>   <list<tibble[,9]>> <glue>           <list>    \n1 I1               [741 × 9] clarity-I1.png   <ggplt2::>\n2 SI2            [9,194 × 9] clarity-SI2.png  <ggplt2::>\n3 SI1           [13,065 × 9] clarity-SI1.png  <ggplt2::>\n4 VS2           [12,258 × 9] clarity-VS2.png  <ggplt2::>\n5 VS1            [8,171 × 9] clarity-VS1.png  <ggplt2::>\n6 VVS2           [5,066 × 9] clarity-VVS2.png <ggplt2::>\n7 VVS1           [3,655 × 9] clarity-VVS1.png <ggplt2::>\n8 IF             [1,790 × 9] clarity-IF.png   <ggplt2::>\n```\n\n\n:::\n:::\n\n\n",
    "supporting": [
      "chapter_26_notes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}