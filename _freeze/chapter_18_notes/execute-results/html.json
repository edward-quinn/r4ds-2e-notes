{
  "hash": "c16856d8926448ed11bfbf9bdf11d13d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"R for Data Science, 2nd Edition - Chapter 18 Notes\"\nfreeze: true\nformat:\n    html:\n        toc: true\n        toc-title: Contents\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n# 18 Missing values\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.4     ✔ readr     2.1.6\n✔ forcats   1.0.1     ✔ stringr   1.6.0\n✔ ggplot2   4.0.1     ✔ tibble    3.3.1\n✔ lubridate 1.9.4     ✔ tidyr     1.3.2\n✔ purrr     1.2.1     \n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ dplyr::filter() masks stats::filter()\n✖ dplyr::lag()    masks stats::lag()\nℹ Use the conflicted package (<http://conflicted.r-lib.org/>) to force all conflicts to become errors\n```\n\n\n:::\n\n```{.r .cell-code}\nlibrary(nycflights13)\n```\n:::\n\n\n\n## 18.2 Explicit missing values\n\nCreating or eliminating missing values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreatment <- tribble(\n  ~person,           ~treatment, ~response,\n  \"Derrick Whitmore\", 1,         7,\n  NA,                 2,         10,\n  NA,                 3,         NA,\n  \"Katherine Burke\",  1,         4\n)\n```\n:::\n\n\nYou can fill in missing values with `tidyr::fill()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntreatment |>\n  fill(everything())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 3\n  person           treatment response\n  <chr>                <dbl>    <dbl>\n1 Derrick Whitmore         1        7\n2 Derrick Whitmore         2       10\n3 Derrick Whitmore         3       10\n4 Katherine Burke          1        4\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 4 × 3\n#>   person           treatment response\n#>   <chr>                <dbl>    <dbl>\n#> 1 Derrick Whitmore         1        7\n#> 2 Derrick Whitmore         2       10\n#> 3 Derrick Whitmore         3       10\n#> 4 Katherine Burke          1        4\n```\n:::\n\n\nThe default behavior of `fill()` is to use last observation carried forward, but this can be altered using the `.direction` argument.\n\nIf missingness can be specified by a number, you can use `dplyr::coalesce()` to replace `NA` with the releveant number:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 4, 5, 7, NA)\ncoalesce(x, 0)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 4 5 7 0\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1] 1 4 5 7 0\n```\n:::\n\n\nGoing the other direciton, from some special value like 999 to `NA` can be handled upon reading data into R. If you can't do that, use `na_if()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(1, 4, 5, 7, -99)\nna_if(x, -99)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  1  4  5  7 NA\n```\n\n\n:::\n\n```{.r .cell-code}\n#> [1]  1  4  5  7 NA\n```\n:::\n\n\n## 18.3 Implicit missing values\n\n**Implicit** refers to the entire row of data being removed from the data frame, rather than **explicitly** filling each column in a given row with `NA`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks <- tibble(\n  year  = c(2020, 2020, 2020, 2020, 2021, 2021, 2021),\n  qtr   = c(   1,    2,    3,    4,    2,    3,    4),\n  price = c(1.88, 0.59, 0.35,   NA, 0.92, 0.17, 2.66)\n)\n```\n:::\n\n\nThis dataset has two missing observations:\n\nThe price in the fourth quarter of 2020 is explicitly missing, because its value is NA.\n\nThe price for the first quarter of 2021 is implicitly missing, because it simply does not appear in the dataset.\n\nMoving between implicit and explicit missingness may be necessary.\n\n**Pivoting**. Pivoting wider makes implicit missingness explicit.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks |>\n  pivot_wider(\n    names_from = qtr, \n    values_from = price\n  )\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 5\n   year   `1`   `2`   `3`   `4`\n  <dbl> <dbl> <dbl> <dbl> <dbl>\n1  2020  1.88  0.59  0.35 NA   \n2  2021 NA     0.92  0.17  2.66\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 2 × 5\n#>    year   `1`   `2`   `3`   `4`\n#>   <dbl> <dbl> <dbl> <dbl> <dbl>\n#> 1  2020  1.88  0.59  0.35 NA   \n#> 2  2021 NA     0.92  0.17  2.66\n```\n:::\n\n\n**Complete**. `tidyr::complete()` generates explicit missing values by defining the combination of rows that should exist. If we want all combinations of year and quarter to exist:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks |>\n  complete(year, qtr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 8 × 3\n   year   qtr price\n  <dbl> <dbl> <dbl>\n1  2020     1  1.88\n2  2020     2  0.59\n3  2020     3  0.35\n4  2020     4 NA   \n5  2021     1 NA   \n6  2021     2  0.92\n7  2021     3  0.17\n8  2021     4  2.66\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 8 × 3\n#>    year   qtr price\n#>   <dbl> <dbl> <dbl>\n#> 1  2020     1  1.88\n#> 2  2020     2  0.59\n#> 3  2020     3  0.35\n#> 4  2020     4 NA   \n#> 5  2021     1 NA   \n#> 6  2021     2  0.92\n#> # ℹ 2 more rows\n```\n:::\n\n\nYou can also use `complete()` on an individual variable:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstocks |>\n  complete(year = 2019:2021, qtr)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 12 × 3\n    year   qtr price\n   <dbl> <dbl> <dbl>\n 1  2019     1 NA   \n 2  2019     2 NA   \n 3  2019     3 NA   \n 4  2019     4 NA   \n 5  2020     1  1.88\n 6  2020     2  0.59\n 7  2020     3  0.35\n 8  2020     4 NA   \n 9  2021     1 NA   \n10  2021     2  0.92\n11  2021     3  0.17\n12  2021     4  2.66\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 12 × 3\n#>    year   qtr price\n#>   <dbl> <dbl> <dbl>\n#> 1  2019     1 NA   \n#> 2  2019     2 NA   \n#> 3  2019     3 NA   \n#> 4  2019     4 NA   \n#> 5  2020     1  1.88\n#> 6  2020     2  0.59\n#> # ℹ 6 more rows\n```\n:::\n\n\nYou can also use *joins* to reveal implicitly missing observations.\n\n`dplyr::anti_join(x,y)` selects only the rows in `x` that don't have a match in `y`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  distinct(faa = dest) |> \n  anti_join(airports)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(faa)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 4 × 1\n  faa  \n  <chr>\n1 BQN  \n2 SJU  \n3 STT  \n4 PSE  \n```\n\n\n:::\n\n```{.r .cell-code}\n#> Joining with `by = join_by(faa)`\n#> # A tibble: 4 × 1\n#>   faa  \n#>   <chr>\n#> 1 BQN  \n#> 2 SJU  \n#> 3 STT  \n#> 4 PSE\n```\n:::\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nflights |> \n  distinct(tailnum) |> \n  anti_join(planes)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nJoining with `by = join_by(tailnum)`\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 722 × 1\n   tailnum\n   <chr>  \n 1 N3ALAA \n 2 N3DUAA \n 3 N542MQ \n 4 N730MQ \n 5 N9EAMQ \n 6 N532UA \n 7 N3EMAA \n 8 N518MQ \n 9 N3BAAA \n10 N3CYAA \n# ℹ 712 more rows\n```\n\n\n:::\n\n```{.r .cell-code}\n#> Joining with `by = join_by(tailnum)`\n#> # A tibble: 722 × 1\n#>   tailnum\n#>   <chr>  \n#> 1 N3ALAA \n#> 2 N3DUAA \n#> 3 N542MQ \n#> 4 N730MQ \n#> 5 N9EAMQ \n#> 6 N532UA \n#> # ℹ 716 more rows\n```\n:::\n\n\n## 18.4 Factors and empty groups\n\nA type of missingness is an empty group, or a factor with a level containing zero observations.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth <- tibble(\n  name   = c(\"Ikaia\", \"Oletta\", \"Leriah\", \"Dashay\", \"Tresaun\"),\n  smoker = factor(c(\"no\", \"no\", \"no\", \"no\", \"no\"), levels = c(\"yes\", \"no\")),\n  age    = c(34, 88, 75, 47, 56),\n)\n```\n:::\n\n\n`count()` automatically removes the level with 0 observations:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth |> count(smoker)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 2\n  smoker     n\n  <fct>  <int>\n1 no         5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 1 × 2\n#>   smoker     n\n#>   <fct>  <int>\n#> 1 no         5\n```\n:::\n\n\nbut we can keep it with `.drop = FALSE`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth |> count(smoker, .drop = FALSE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 2\n  smoker     n\n  <fct>  <int>\n1 yes        0\n2 no         5\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 2 × 2\n#>   smoker     n\n#>   <fct>  <int>\n#> 1 yes        0\n#> 2 no         5\n```\n:::\n\n\nThe same behavior applies to ggplot2's discrete axes:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete()\n```\n\n::: {.cell-output-display}\n![](chapter_18_notes_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n\n```{.r .cell-code}\nggplot(health, aes(x = smoker)) +\n  geom_bar() +\n  scale_x_discrete(drop = FALSE)\n```\n\n::: {.cell-output-display}\n![](chapter_18_notes_files/figure-html/unnamed-chunk-15-2.png){width=672}\n:::\n:::\n\n\nThe same behavior applies to `group_by()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhealth |> \n  group_by(smoker, .drop = FALSE) |> \n  summarize(\n    n = n(),\n    mean_age = mean(age),\n    min_age = min(age),\n    max_age = max(age),\n    sd_age = sd(age)\n  )\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: There were 2 warnings in `summarize()`.\nThe first warning was:\nℹ In argument: `min_age = min(age)`.\nℹ In group 1: `smoker = yes`.\nCaused by warning in `min()`:\n! no non-missing arguments to min; returning Inf\nℹ Run `dplyr::last_dplyr_warnings()` to see the 1 remaining warning.\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  smoker     n mean_age min_age max_age sd_age\n  <fct>  <int>    <dbl>   <dbl>   <dbl>  <dbl>\n1 yes        0      NaN     Inf    -Inf   NA  \n2 no         5       60      34      88   21.6\n```\n\n\n:::\n\n```{.r .cell-code}\n#> # A tibble: 2 × 6\n#>   smoker     n mean_age min_age max_age sd_age\n#>   <fct>  <int>    <dbl>   <dbl>   <dbl>  <dbl>\n#> 1 yes        0      NaN     Inf    -Inf   NA  \n#> 2 no         5       60      34      88   21.6\n```\n:::\n\n\n",
    "supporting": [
      "chapter_18_notes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}